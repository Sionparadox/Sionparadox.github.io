export const metadata = {
  title: '[Gold II] 닭싸움 팀 정하기 - 1765',
  date: '2025-07-03 07:10:41',
  tags: ['그래프 이론', '자료 구조', '그래프 탐색', '분리 집합'],
  description: '[Gold II] 닭싸움 팀 정하기 - 1765',
};

# [Gold II] 닭싸움 팀 정하기 - 1765 

[문제 링크](https://www.acmicpc.net/problem/1765) 

### 성능 요약

메모리: 34976 KB, 시간: 284 ms

### 분류

그래프 이론, 자료 구조, 그래프 탐색, 분리 집합

### 제출 일자

2025년 7월 3일 16:10:12

### 문제 설명

닭싸움은 월드의 전통이다. 이번 캠프에서도 어김없이 닭싸움 대회가 열렸다. 그런데, 닭싸움을 하기 위해서는 반드시 누가 우리 편이고, 누가 우리 편이 아닌지를 알아야 할 것이다. 닭싸움의 팀을 정하는 원칙은, 평소 학생들의 인간관계에 따라 다음과 같이 정리할 수 있다.

	내 친구의 친구는 내 친구이다.
	내 원수의 원수도 내 친구이다.

이 때 두 학생이 친구이면 같은 팀에 속해있어야 하며, 같은 팀에 속해 있는 사람들끼리는 전부 친구여야 한다.

학생들의 인간관계가 주어지면, 닭싸움을 위한 팀 정하기를 할 때, 최대 얼마나 많은 팀이 만들어질 수 있는지 알아내는 프로그램을 작성하시오.

### 입력 

 첫째 줄에 학생의 수 n이 주어진다. 각 학생들은 1부터 n까지 번호가 매겨져 있다. (2 ≤ n ≤ 1000) 

둘째 줄에 학생 간의 인간관계 중 알려진 것의 개수 m이 주어진다. (1 ≤ m ≤ 5000)

다음 m개의 줄에는 한 줄에 한 개씩, 학생 간의 인간관계가 F p q 혹은 E p q의 형태로 공백으로 구분되어 주어진다. (1 ≤ p 

첫 번째 글자가 F인 경우에는 p와 q가 친구인 것이고, E인 경우는 p와 q가 원수인 경우이다. 

입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.

### 출력 

 첫째 줄에, 가능한 최대 팀 개수를 출력한다.

### 풀이
```python
import sys
from collections import defaultdict
input = sys.stdin.readline

N = int(input())
M = int(input())

enemy = defaultdict(list)
parent = [x for x in range(N+1)]

def find(node):
    if node == parent[node]:
        return node
    parent[node] = find(parent[node])
    return parent[node]

def union(u, v):
    rootU, rootV = find(u), find(v)
    if rootU != rootV:
        parent[rootV] = rootU

for _ in range(M):
    type, u, v = input().split()
    u, v = int(u), int(v)
    if type == 'F':
        union(u, v)
    else:
        enemy[u].append(v)
        enemy[v].append(u)

for i in enemy.keys():
    for e in enemy[i]:
        for f in enemy[e]:
            union(i, f)

cnt = set()
for p in parent[1:]:
    p = find(p)
    if p not in cnt:
        cnt.add(p)

print(len(cnt))
```