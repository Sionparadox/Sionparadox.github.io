export const metadata = {
  title: '[Platinum IV] 축구 전술 - 3977',
  date: '2025-08-29 08:21:06',
  tags: ['그래프 이론', '강한 연결 요소'],
  description: '[Platinum IV] 축구 전술 - 3977',
};

# [Platinum IV] 축구 전술 - 3977 

[문제 링크](https://www.acmicpc.net/problem/3977) 

### 성능 요약

메모리: 64916 KB, 시간: 1672 ms

### 분류

그래프 이론, 강한 연결 요소

### 제출 일자

2025년 8월 29일 17:20:46

### 문제 설명

![그림](https://www.acmicpc.net/upload/images2/field(1).png)

World Soccer Championship이 다가오고 있다! 천재적인 전술을 창조하는 플랜 아티스트 감독 도현이는 자신의 팀이 승리하도록 만반의 준비를 가하고 있다. 도현이의 전략은 경기장을 여러 개의 구역으로 나누고, 어떤 선수가 A구역에서 B구역으로 이동하게 하는 움직임을 (A, B)로 표현한다. 모든 도현이의 팀 선수들이 이 움직임만을 따라서 이동한다면 승리하리라고 도현이는 확신한다.

도현이는 선수들에게 자신의 전술을 말해주며, 다른 모든 구역에 도달할 수 있는 시작 구역을 찾은 뒤 지시한 움직임만을 따라가라고 했다. 그러나 도현이는 한 가지 간과한 것이 있었는데 그건 선수들이 자신만큼 똑똑하지 않다는 것이다. 선수들은 그러한 시작 구역을 찾는 것이 어려웠다. 이제 당신이 적절한 시작 구역을 찾아줘야 한다.

 

### 입력 

 첫 번째 줄에 테스트 케이스의 개수가 주어지며, 이는 11보다 작거나 같은 정수이다.

그 다음 줄부터 여러 개의 테스트 케이스가 주어지는데, 각 테스트 케이스마다 첫 번째 줄에 구역의 수 N, 지시한 움직임의 수 M이 주어지며 1 ≤ N, M ≤ 100,000 이다. 그 다음 M개의 줄에 걸쳐서 움직임 (A, B)가 주어지며, A, B는 0 ≤ A, B 

각 테스트 케이스는 하나의 빈 줄로 구분된다.

### 출력 

 각 테스트 케이스마다 가능한 모든 시작 구역을 오름차순으로 한 줄에 하나씩 출력한다. 만약 그러한 시작 구역이 없으면, "Confused"를 출력한다.

각 테스트 케이스의 끝에는 하나의 빈 줄을 출력한다.

### 풀이
```python
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

def DFS(node):
    global label, group_num
    label += 1
    labels[node] = label
    parent = label
    stack.append(node)
    visited[node] = True
    
    for nxt in graph[node]:
        if not labels[nxt]:
            parent = min(parent, DFS(nxt))
        elif visited[nxt]:
            parent = min(parent, labels[nxt])
    
    if parent == labels[node]:
        group = []
        while stack:
            cur = stack.pop()
            group_id[cur] = group_num
            group.append(cur)
            visited[cur] = False
            if cur == node:
                break
        groups.append(group)
        group_num += 1
    
    return parent

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    graph = [[] for _ in range(N)]
    for _ in range(M):
        u, v = map(int, input().split())
        graph[u].append(v)
    
    labels = [0]*N
    label = 0
    visited = [False]*N
    groups = []
    group_id = [-1]*N
    group_num = 0
    stack = []
    for i in range(N):
        if not labels[i]:
            DFS(i)
    
    G = len(groups)
    indegree = [0]*G
    for node in range(N):
        for nxt in graph[node]:
            if group_id[node] != group_id[nxt]:
                indegree[group_id[nxt]] += 1
    cnt = 0
    res = []
    for i in range(G):
        if indegree[i] == 0:
            cnt += 1
            res.extend(groups[i])
    if cnt != 1:
        print("Confused")
    else:
        print('\n'.join(map(str, sorted(res))))
    print()
    input()
```