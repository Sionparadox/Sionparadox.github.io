export const metadata = {
  title: '[Platinum V] 백조의 호수 - 3197',
  date: '2025-07-29 09:26:03',
  tags: ['그래프 이론', '자료 구조', '그래프 탐색', '너비 우선 탐색', '분리 집합', '격자 그래프'],
  description: '[Platinum V] 백조의 호수 - 3197',
};

# [Platinum V] 백조의 호수 - 3197 

[문제 링크](https://www.acmicpc.net/problem/3197) 

### 성능 요약

메모리: 390436 KB, 시간: 2848 ms

### 분류

그래프 이론, 자료 구조, 그래프 탐색, 너비 우선 탐색, 분리 집합, 격자 그래프

### 제출 일자

2025년 7월 29일 18:25:29

### 문제 설명

두 마리의 백조가 호수에서 살고 있었다. 그렇지만 두 마리는 호수를 덮고 있는 빙판으로 만나지 못한다.

호수는 행이 R개, 열이 C개인 직사각형 모양이다. 어떤 칸은 얼음으로 덮여있다.

호수는 차례로 녹는데, 매일 물 공간과 접촉한 모든 빙판 공간은 녹는다. 두 개의 공간이 접촉하려면 가로나 세로로 닿아 있는 것만 (대각선은 고려하지 않는다) 생각한다.

아래에는 세 가지 예가 있다.

...XXXXXX..XX.XXX ....XXXX.......XX .....XX.......... 
....XXXXXXXXX.XXX .....XXXX..X..... ......X.......... 
...XXXXXXXXXXXX.. ....XXX..XXXX.... .....X.....X..... 
..XXXXX..XXXXXX.. ...XXX....XXXX... ....X......XX.... 
.XXXXXX..XXXXXX.. ..XXXX....XXXX... ...XX......XX.... 
XXXXXXX...XXXX... ..XXXX.....XX.... ....X............ 
..XXXXX...XXX.... ....XX.....X..... ................. 
....XXXXX.XXX.... .....XX....X..... ................. 
      처음               첫째 날             둘째 날

백조는 오직 물 공간에서 세로나 가로로만(대각선은 제외한다) 움직일 수 있다.

며칠이 지나야 백조들이 만날 수 있는 지 계산하는 프로그램을 작성하시오.

### 입력 

 입력의 첫째 줄에는 R과 C가 주어진다. 단, 1 ≤ R, C ≤ 1500.

다음 R개의 줄에는 각각 길이 C의 문자열이 하나씩 주어진다. '.'은 물 공간, 'X'는 빙판 공간, 'L'은 백조가 있는 공간으로 나타낸다.

### 출력 

 첫째 줄에 문제에서 주어진 걸리는 날을 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline

R, C = map(int, input().split())
lake = [list(input().strip()) for _ in range(R)]
melt_day = [[-1]*C for _ in range(R)]
pos = []
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

queue = deque()
for r in range(R):
    for c in range(C):
        if lake[r][c] == 'L':
            pos.append((r, c))
        if lake[r][c] != 'X':
            melt_day[r][c] = 0
            queue.append((r, c))

maxDay = -1
while queue:
    r, c = queue.popleft()
    for dr, dc in directions:
        nr, nc = r+dr, c+dc
        if nr=R or nc=C:
            continue
        if melt_day[nr][nc] != -1:
            continue
        if lake[nr][nc] == 'X':
            melt_day[nr][nc] = melt_day[r][c] + 1
            maxDay = melt_day[nr][nc]
            queue.append((nr, nc))

def check(k):
    queue = deque([pos[0]])
    visited = [[False]*C for _ in range(R)]
    visited[pos[0][0]][pos[0][1]] = True
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if nr=R or nc=C:
                continue
            if (nr, nc) == pos[1]:
                return True
            if visited[nr][nc] or melt_day[nr][nc]>k:
                continue
            visited[nr][nc] = True
            queue.append((nr, nc))
    
    return False

s = 0
e = maxDay

while s<e:
    mid = (s+e)//2
    if check(mid):
        e = mid
    else:
        s = mid+1

print(s)

'''
빙판이 녹는 날짜를 만들고
K에 대해 이분탐색하며 연결되었는지 확인
'''
```