export const metadata = {
  title: '[Platinum III] 2-SAT - 4 - 11281',
  date: '2025-08-31 07:31:07',
  tags: ['그래프 이론', '강한 연결 요소', '역추적', '2-sat'],
  description: '[Platinum III] 2-SAT - 4 - 11281',
};

# [Platinum III] 2-SAT - 4 - 11281 

[문제 링크](https://www.acmicpc.net/problem/11281) 

### 성능 요약

메모리: 46460 KB, 시간: 320 ms

### 분류

그래프 이론, 강한 연결 요소, 역추적, 2-sat

### 제출 일자

2025년 8월 31일 16:30:04

### 문제 설명

2-SAT은 N개의 불리언 변수 가 있을 때, 2-CNF 식을 true로 만들기위해 를 어떤 값으로 정해야하는지를 구하는 문제이다.

2-CNF식은  와 같은 형태이다. 여기서 괄호로 묶인 식을 절(clause)라고 하는데, 절은 2개의 변수를 한 것으로 이루어져 있다. 는 OR, 는 AND, 은 NOT을 나타낸다.

변수의 개수 N과 절의 개수 M, 그리고 식 가 주어졌을 때, 식 를 true로 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.

예를 들어, N = 3, M = 4이고,  인 경우에 을 false, 을 false, 를 true로 정하면 식 를 true로 만들 수 있다. 하지만, N = 1, M = 2이고, 인 경우에는 에 어떤 값을 넣어도 식 f를 true로 만들 수 없다.

### 입력 

 첫째 줄에 변수의 개수 N (1 ≤ N ≤ 10,000)과 절의 개수 M (1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에는 절이 주어진다. 절은 두 정수 i와 j (1 ≤ |i|, |j| ≤ N)로 이루어져 있으며, i와 j가 양수인 경우에는 각각 , 를 나타내고, 음수인 경우에는 , 를 나타낸다.

### 출력 

 첫째 줄에 식 를 true로 만들 수 있으면 1을, 없으면 0을 출력한다.

를 true로 만들 수 있는 경우에는 둘째 줄에 식 를 true로 만드는 의 값을 부터 순서대로 출력한다. true는 1, false는 0으로 출력한다.

### 풀이
```python
import sys
from collections import deque
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

N, M = map(int, input().split())
def trans_idx(i):
    if i>0: return i-1
    else: return -i-1+N

graph = [[] for _ in range(2*N)]
for _ in range(M):
    u, v = map(int, input().split())
    graph[trans_idx(-u)].append(trans_idx(v))
    graph[trans_idx(-v)].append(trans_idx(u))

labels = [0]*(2*N)
label = 0
visited = [False]*(2*N)
stack = []
groups = []
group_id = [-1]*(2*N)
group_num = 0
def DFS(node):
    global label, group_num
    label += 1
    labels[node] = label
    parent = label
    stack.append(node)
    visited[node] = True
    for nxt in graph[node]:
        if labels[nxt] == 0:
            parent = min(parent, DFS(nxt))
        elif visited[nxt]:
            parent = min(parent, labels[nxt])
    
    if parent == labels[node]:
        group = []
        while stack:
            cur = stack.pop()
            visited[cur] = False
            group.append(cur)
            group_id[cur] = group_num
            if cur == node:
                break
        groups.append(group)
        group_num += 1
    return parent

for i in range(2*N):
    if not labels[i]:
        DFS(i)

answer = 1
for i in range(N):
    if group_id[i] == group_id[i+N]:
        answer = 0
        break

if answer == 0:
    print(answer)
    exit(0)

G = len(groups)
indegree = [0]*G
for node in range(2*N):
    for nxt in graph[node]:
        if group_id[node] != group_id[nxt]:
            indegree[group_id[nxt]] += 1

queue = deque()
for i in range(G):
    if indegree[i] == 0:
        queue.append(i)

order = []
while queue:
    cur = queue.popleft()
    order.append(cur)
    
    for node in groups[cur]:
        for nxt in graph[node]:
            nid = group_id[nxt]
            if cur == nid: continue
            indegree[nid] -= 1
            if indegree[nid] == 0:
                queue.append(nid)
     
group_value = [-1]*G           
for g in order:
    if group_value[g] == -1:
        group_value[g] = 0
        for node in groups[g]:
            rn = node+N if node < N else node-N
            group_value[group_id[rn]] = 1

value = [0]*N
for i in range(N):
    if group_value[group_id[i]]:
        value[i] = 1
        
print(answer)
print(*value)
```