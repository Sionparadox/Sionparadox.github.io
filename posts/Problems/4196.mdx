export const metadata = {
  title: '[Platinum IV] 도미노 - 4196',
  date: '2025-08-29 07:41:51',
  tags: ['그래프 이론', '방향 비순환 그래프', '위상 정렬', '강한 연결 요소'],
  description: '[Platinum IV] 도미노 - 4196',
};

# [Platinum IV] 도미노 - 4196 

[문제 링크](https://www.acmicpc.net/problem/4196) 

### 성능 요약

메모리: 73440 KB, 시간: 960 ms

### 분류

그래프 이론, 방향 비순환 그래프, 위상 정렬, 강한 연결 요소

### 제출 일자

2025년 8월 29일 16:41:33

### 문제 설명

도미노는 재밌다. 도미노 블록을 일렬로 길게 늘어세운 뒤 블록 하나를 넘어뜨리면 그 블록이 넘어지며 다음 블록을 넘어뜨리는 일이 반복되어 일렬로 늘어선 블록들을 연쇄적으로 모두 쓰러뜨릴 수 있다. 그러나, 가끔씩 도미노가 다른 블록을 넘어뜨리지 못하게 배치되어 있다면, 우리는 다음 블록을 수동으로 넘어뜨려야 한다.

이제 각 도미노 블록의 배치가 주어졌을 때, 모든 블록을 넘어뜨리기 위해 손으로 넘어뜨려야 하는 블록 개수의 최솟값을 구하자.

### 입력 

 첫 번째 줄에 테스트 케이스의 개수가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 두 정수 N, M이 주어지며 두 수는 100,000을 넘지 않는다. N은 도미노의 개수를, M은 관계의 개수를 나타낸다. 도미노 블록의 번호는 1과 N 사이의 정수다. 다음 M개의 줄에는 각각 두 정수 x, y가 주어지는데, 이는 x번 블록이 넘어지면 y번 블록도 넘어짐을 뜻한다.

### 출력 

 각 테스트 케이스마다 한 줄에 정수 하나를 출력한다. 정답은 손으로 넘어뜨려야 하는 최소의 도미노 블록 개수이다.

### 풀이
```python
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

def DFS(node):
    global label, group_num
    label += 1
    labels[node] = label
    parent = label
    stack.append(node)
    visited[node] = True
    
    for nxt in graph[node]:
        if labels[nxt] == 0:
            parent = min(parent, DFS(nxt))
        elif visited[nxt]:
            parent = min(parent, labels[nxt])
    
    if parent == labels[node]:
        res = []
        while stack:
            cur = stack.pop()
            group_id[cur] = group_num
            res.append(cur)
            visited[cur] = False
            if node == cur:
                break
        groups.append(res)
        group_num += 1
    
    return parent
    

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    graph = [[] for _ in range(N+1)]
    for _ in range(M):
        u, v = map(int, input().split())
        graph[u].append(v)
    labels = [0]*(N+1)
    visited = [False]*(N+1)
    stack = []
    groups = []
    group_id = [-1]*(N+1)
    label = group_num = 0
    for i in range(1, N+1):
        if labels[i] == 0:
            p = DFS(i)
    
    G = len(groups)
    indegree = [0]*G
    for node in range(1, N+1):
        for nxt in graph[node]:
            if group_id[node] != group_id[nxt]:
                indegree[group_id[nxt]] += 1
    
    answer = 0
    for i in range(G):
        if indegree[i] == 0:
            answer += 1
    
    print(answer)
```