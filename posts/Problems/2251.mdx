export const metadata = {
  title: '[Gold IV] 물통 - 2251',
  date: '2026-02-27 07:23:47',
  tags: ['그래프 이론', '그래프 탐색', '너비 우선 탐색', '깊이 우선 탐색'],
  description: '[Gold IV] 물통 - 2251',
};

# [Gold IV] 물통 - 2251 

[문제 링크](https://www.acmicpc.net/problem/2251) 

### 성능 요약

메모리: 98444 KB, 시간: 248 ms

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색

### 제출 일자

2026년 2월 27일 16:23:30

### 문제 설명

각각 부피가 A, B, C(1≤A, B, C≤200) 리터인 세 개의 물통이 있다. 처음에는 앞의 두 물통은 비어 있고, 세 번째 물통은 가득(C 리터) 차 있다. 이제 어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이때에는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다. 이 과정에서 손실되는 물은 없다고 가정한다.

이와 같은 과정을 거치다보면 세 번째 물통(용량이 C인)에 담겨있는 물의 양이 변할 수도 있다. 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오.

### 입력 

 첫째 줄에 세 정수 A, B, C가 주어진다.

### 출력 

 첫째 줄에 공백으로 구분하여 답을 출력한다. 각 용량은 오름차순으로 정렬한다.

### 풀이
```python
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

A, B, C = map(int, input().split())
visited = [[[False]*(C+1) for _ in range(B+1)] for _ in range(A+1)]

answer = []
def DFS(a,b,c):
    if visited[a][b][c]:
        return
    if a == 0:
        answer.append(c)
    
    visited[a][b][c] = True
    a_left = A-a
    b_left = B-b
    c_left = C-c
    if a_left:
        DFS(min(A, a+b), max(0,b-a_left), c)
        DFS(min(A, a+c), b, max(0, c-a_left))
    if b_left:
        DFS(max(0, a-b_left), min(B, a+b) , c)
        DFS(a, min(B, b+c), max(0, c-b_left))
    if c_left:
        DFS(max(0, a-c_left), b, min(C, a+c))
        DFS(a, max(0, b-c_left), min(C, b+c))

DFS(0,0,C)
print(*sorted(answer))

'''
방문체크하며 DFS로 값 갱신
b->a, c->a
a->b, c->b
a->c, b->c

'''
```