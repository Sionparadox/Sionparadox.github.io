export const metadata = {
  title: '[Gold III] 마법사 상어와 파이어스톰 - 20058',
  date: '2025-07-25 09:54:20',
  tags: ['구현', '그래프 이론', '그래프 탐색', '시뮬레이션', '너비 우선 탐색', '깊이 우선 탐색'],
  description: '[Gold III] 마법사 상어와 파이어스톰 - 20058',
};

# [Gold III] 마법사 상어와 파이어스톰 - 20058 

[문제 링크](https://www.acmicpc.net/problem/20058) 

### 성능 요약

메모리: 35116 KB, 시간: 3772 ms

### 분류

구현, 그래프 이론, 그래프 탐색, 시뮬레이션, 너비 우선 탐색, 깊이 우선 탐색

### 제출 일자

2025년 7월 25일 18:52:19

### 문제 설명

마법사 상어는 파이어볼과 토네이도를 조합해 파이어스톰을 시전할 수 있다. 오늘은 파이어스톰을 크기가 2N × 2N인 격자로 나누어진 얼음판에서 연습하려고 한다. 위치 (r, c)는 격자의 r행 c열을 의미하고, A[r][c]는 (r, c)에 있는 얼음의 양을 의미한다. A[r][c]가 0인 경우 얼음이 없는 것이다.

파이어스톰을 시전하려면 시전할 때마다 단계 L을 결정해야 한다. 파이어스톰은 먼저 격자를 2L × 2L 크기의 부분 격자로 나눈다. 그 후, 모든 부분 격자를 시계 방향으로 90도 회전시킨다. 이후 얼음이 있는 칸 3개 또는 그 이상과 인접해있지 않은 칸은 얼음의 양이 1 줄어든다. (r, c)와 인접한 칸은 (r-1, c), (r+1, c), (r, c-1), (r, c+1)이다. 아래 그림의 칸에 적힌 정수는 칸을 구분하기 위해 적은 정수이다.

	
		
			

![그림](https://upload.acmicpc.net/68137f5d-fdbd-48c6-92f0-0a74ee53b0c2/-/preview/)

			

![그림](https://upload.acmicpc.net/4216e4de-a9f7-4bf0-9385-e20c583c1228/-/preview/)

			

![그림](https://upload.acmicpc.net/a58a4219-afc7-4f77-a194-a5495882eeb4/-/preview/)

		
		
			마법을 시전하기 전
			L = 1
			L = 2
		
	

마법사 상어는 파이어스톰을 총 Q번 시전하려고 한다. 모든 파이어스톰을 시전한 후, 다음 2가지를 구해보자.

	남아있는 얼음 A[r][c]의 합
	남아있는 얼음 중 가장 큰 덩어리가 차지하는 칸의 개수

얼음이 있는 칸이 얼음이 있는 칸과 인접해 있으면, 두 칸을 연결되어 있다고 한다. 덩어리는 연결된 칸의 집합이다.

### 입력 

 첫째 줄에 N과 Q가 주어진다. 둘째 줄부터 2N개의 줄에는 격자의 각 칸에 있는 얼음의 양이 주어진다. r번째 줄에서 c번째 주어지는 정수는 A[r][c] 이다.

마지막 줄에는 마법사 상어가 시전한 단계 L1, L2, ..., LQ가 순서대로 주어진다.

### 출력 

 첫째 줄에 남아있는 얼음 A[r][c]의 합을 출력하고, 둘째 줄에 가장 큰 덩어리가 차지하는 칸의 개수를 출력한다. 단, 덩어리가 없으면 0을 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline

N, Q = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(2**N)]
cmd = list(map(int, input().split()))
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
visited = [[False]*(2**N) for _ in range(2**N)]

def BFS(r, c):
    visited[r][c] = True
    queue = deque([(r, c)])
    cnt = 0
    while queue:
        r, c = queue.popleft()
        cnt += 1
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if nr=2**N or nc=2**N:
                continue
            if not visited[nr][nc] and board[nr][nc] >0:
                queue.append((nr, nc))
                visited[nr][nc] = True
    return cnt

def rotate(r, c, k):
    L = 2**k
    for depth in range(L//2):
        first = depth
        last = L-1-depth
        for i in range(first, last):
            offset = i - first
            top = board[r + first][c + i]
            # 왼쪽 → 위쪽
            board[r + first][c + i] = board[r + last - offset][c + first]
            # 아래쪽 → 왼쪽
            board[r + last - offset][c + first] = board[r + last][c + last - offset]
            # 오른쪽 → 아래쪽
            board[r + last][c + last - offset] = board[r + i][c + last]
            # 위쪽 → 오른쪽
            board[r + i][c + last] = top

def spell(k):
    L = 2**k
    for r in range(0, 2**N, L):
        for c in range(0, 2**N, L):
            rotate(r, c, k)
    
    candidates = []
    for r in range(2**N):
        for c in range(2**N):
            if board[r][c] == 0:
                continue
            cnt = 0
            for dr, dc in directions:
                nr, nc = r+dr, c+dc
                if 00:
            cnt = BFS(r, c)
            maxVal = max(maxVal, cnt)

print(tot)
print(maxVal)
```