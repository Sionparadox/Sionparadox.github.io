export const metadata = {
  title: '[Gold II] 가스관 - 2931',
  date: '2025-08-07 06:32:53',
  tags: ['구현', '시뮬레이션'],
  description: '[Gold II] 가스관 - 2931',
};

# [Gold II] 가스관 - 2931 

[문제 링크](https://www.acmicpc.net/problem/2931) 

### 성능 요약

메모리: 32412 KB, 시간: 36 ms

### 분류

구현, 시뮬레이션

### 제출 일자

2025년 8월 7일 15:32:37

### 문제 설명

러시아 가스를 크로아티아로 운반하기 위해 자그레브와 모스코바는 파이프라인을 디자인하고 있다. 두 사람은 실제 디자인을 하기 전에 파이프 매니아 게임을 이용해서 설계를 해보려고 한다.

이 게임에서 유럽은 R행 C열로 나누어져 있다. 각 칸은 비어있거나, 아래 그림과 같은 일곱가지 기본 블록으로 이루어져 있다.

	
		
			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/73x118/29,0/-/preview/)

			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/127x118/168,0/-/preview/)

			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/116x118/339,0/-/preview/)

			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/91x118/519,0/-/preview/)

			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/90x118/685,0/-/preview/)

			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/89x118/853,0/-/preview/)

			

![그림](https://upload.acmicpc.net/3a92cfe2-8d8f-4059-b4e1-1d23b2e7df12/-/crop/90x118/1018,0/-/preview/)

		
		
			블록 '|'
			블록 '-'
			블록 '+'
			블록 '1'
			블록 '2'
			블록 '3'
			블록 '4'
		
	

가스는 모스크바에서 자그레브로 흐른다. 가스는 블록을 통해 양방향으로 흐를 수 있다. '+'는 특별한 블록으로, 아래 예시처럼 두 방향 (수직, 수평)으로 흘러야 한다.

![그림](https://upload.acmicpc.net/66956a75-fdf1-4706-923d-cb2794fc0ab9/-/preview/)

파이프 라인의 설계를 마친 후 두 사람은 잠시 저녁을 먹으러 갔다. 그 사이 해커가 침임해 블록 하나를 지웠다. 지운 블록은 빈 칸이 되어있다.

해커가 어떤 칸을 지웠고, 그 칸에는 원래 어떤 블록이 있었는지 구하는 프로그램을 작성하시오.

### 입력 

 첫째 줄에 유럽의 크기 R과 C가 주어진다. (1 ≤ R, C ≤ 25)

다음 R개 줄에는 C개 글자가 주어지며, 다음과 같은 글자로 이루어져 있다.

	빈칸을 나타내는 '.'
	블록을 나타내는 '|'(아스키 124), '-','+','1','2','3','4'
	모스크바의 위치를 나타내는 'M'과 자그레브를 나타내는 'Z'. 두 글자는 한 번만 주어진다.

항상 답이 존재하고, 가스의 흐름이 유일한 경우만 입력으로 주어진다, 또, 모스크바와 자그레브가 하나의 블록과 인접해 있는 입력만 주어진다. 또, 불필요한 블록이 존재하지 않는다. 즉, 없어진 블록을 추가하면, 모든 블록에 가스가 흐르게 된다.

### 출력 

 지워진 블록의 행과 열 위치를 출력하고, 어떤 블록이었는지를 출력한다.

### 풀이
```python
import sys
input = sys.stdin.readline

R, C = map(int, input().split())
board = [list(input().strip()) for _ in range(R)]
directions = [(-1, 0), (0, 1), (1, 0), (0, -1)] #URDL
pipes = ['|', '-', '+', '1', '2', '3', '4']
pos = (-1, -1)
d = -1
for i in range(R):
    for j in range(C):
        if board[i][j] == 'M':
            pos = (i, j)
            for didx in range(4):
                ni, nj = i+directions[didx][0], j+directions[didx][1]
                if 0=R or c=C:
            return False
        if board[r][c] == 'Z':
            return True
        d = pipe(board[r][c], d)
        if d == -1:
            return False
        

blank = (-1, -1)
while True:
    r, c = pos
    dr, dc = directions[d]
    r, c = r+dr, c+dc
    if board[r][c] == '.':
        blank = (r, c)
        break
    d = pipe(board[r][c], d)
    pos = (r, c)

for p in pipes:
    board[blank[0]][blank[1]] = p
    if check(pos[0], pos[1], d):
        print(blank[0]+1, blank[1]+1, p)
        break

'''
M부터 파이프를 따라 이동하며 빈곳이 나오면 멈추고 현재 위치와 방향을 기억해둠.
이후 빈칸에 하나씩 채워보며 이동이 가능한 모양만 찾아냄
'''
```