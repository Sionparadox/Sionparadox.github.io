export const metadata = {
  title: '[Platinum III] 도시 왕복하기 2 - 2316',
  date: '2025-09-05 07:04:37',
  tags: ['그래프 이론', '최대 유량'],
  description: '[Platinum III] 도시 왕복하기 2 - 2316',
};

# [Platinum III] 도시 왕복하기 2 - 2316 

[문제 링크](https://www.acmicpc.net/problem/2316) 

### 성능 요약

메모리: 43604 KB, 시간: 156 ms

### 분류

그래프 이론, 최대 유량

### 제출 일자

2025년 9월 5일 16:04:09

### 문제 설명

N개의 도시가 P개의 양방향 길로 연결되어 있다. 이석원은 1번 도시와 2번 도시 사이를 오가며 워해머를 한다. 성실한 이석원은 두 도시 사이를 최대한 많이 왔다 갔다 하려 하는데, 이때 한 번 방문했던 도시(1, 2번 도시 제외)를 두 번 이상 방문하지 않으려 한다. 한 번 1번 도시와 2번 도시 사이를 오갈 때, 반드시 한 개 이상의 도시를 중간에 거쳐야 한다. 입력에는 1번 도시와 2번 도시를 연결하는 길은 없다. 도시의 번호는 1번부터 N번까지이다.

### 입력 

 첫째 줄에 두 정수 N(3 ≤ N ≤ 400), P(1 ≤ P ≤ 10,000)이 주어진다. 다음 P개의 줄에는 각 길이 연결하는 서로 다른 두 도시의 번호가 주어진다.

### 출력 

 첫째 줄에 왔다 갔다 할 수 있는 최대 횟수를 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline
INF = float('inf')

N, P = map(int, input().split())
L = N*2
graph = [[] for _ in range(L)]
capacity = [[0]*L for _ in range(L)]
flow = [[0]*L for _ in range(L)]
parent = [-1]*L

for i in range(N):
    if i in (0, 1):
        capacity[i][i+N] = INF
    else:
        capacity[i][i+N] = 1
        
    graph[i].append(i+N)
    graph[i+N].append(i)
        
for _ in range(P):
    s, e = map(int, input().split())
    s, e = s-1, e-1
    graph[s+N].append(e)
    graph[e].append(s+N)
    graph[e+N].append(s)
    graph[s].append(e+N)
    capacity[s+N][e] = 1
    capacity[e+N][s] = 1

def BFS(source, sink):
    visited = [False]*L
    queue = deque([source])
    visited[source] = True
    while queue:
        curr = queue.popleft()
        for nxt in graph[curr]:
            if visited[nxt]: continue
            if capacity[curr][nxt] > flow[curr][nxt]:
                visited[nxt] = True
                queue.append(nxt)
                parent[nxt] = curr
                if nxt == sink:
                    return True
    return False

source, sink = N, 1
max_flow = 0
while True:
    if not BFS(source, sink):
        break
    
    u = sink
    while u != source:
        flow[parent[u]][u] += 1
        flow[u][parent[u]] -= 1
        u = parent[u]
    
    max_flow += 1

print(max_flow)
```