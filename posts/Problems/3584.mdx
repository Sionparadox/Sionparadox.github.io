export const metadata = {
  title: '[Gold IV] 가장 가까운 공통 조상 - 3584',
  date: '2025-08-29 05:37:26',
  tags: ['그래프 이론', '그래프 탐색', '트리', '깊이 우선 탐색', '최소 공통 조상'],
  description: '[Gold IV] 가장 가까운 공통 조상 - 3584',
};

# [Gold IV] 가장 가까운 공통 조상 - 3584 

[문제 링크](https://www.acmicpc.net/problem/3584) 

### 성능 요약

메모리: 37440 KB, 시간: 180 ms

### 분류

그래프 이론, 그래프 탐색, 트리, 깊이 우선 탐색, 최소 공통 조상

### 제출 일자

2025년 8월 29일 14:37:11

### 문제 설명

루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Ancestor)은 다음과 같이 정의됩니다.

	두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.

![nca.png](https://upload.acmicpc.net/4f2eae58-31bf-445f-a7a3-625505e7102c/-/preview/)

예를 들어  15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.

루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요

### 입력 

 첫 줄에 테스트 케이스의 개수 T가 주어집니다.

각 테스트 케이스마다, 첫째 줄에 트리를 구성하는 노드의 수 N이 주어집니다. (2 ≤ N ≤ 10,000)

그리고 그 다음 N-1개의 줄에 트리를 구성하는 간선 정보가 주어집니다. 한 간선 당 한 줄에 두 개의 숫자 A B 가 순서대로 주어지는데, 이는 A가 B의 부모라는 뜻입니다. (당연히 정점이 N개인 트리는 항상 N-1개의 간선으로 이루어집니다!) A와 B는 1 이상 N 이하의 정수로 이름 붙여집니다.

테스트 케이스의 마지막 줄에 가장 가까운 공통 조상을 구할 두 노드가 주어집니다.

### 출력 

 각 테스트 케이스 별로, 첫 줄에 입력에서 주어진 두 노드의 가장 가까운 공통 조상을 출력합니다.

### 풀이
```python
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

def LCA(u, v):
    if depth[u] = 2**i:
            u = parent[i][u]
    
    if u == v:
        return u
    
    for i in range(K-1, -1, -1):
        if parent[i][u] != parent[i][v]:
            u = parent[i][u]
            v = parent[i][v]
    
    return parent[0][u]
    
def DFS(node, parent):
    for child in graph[node]:
        if child != parent:
            depth[child] = depth[node]+1
            DFS(child, node)

T = int(input())
for _ in range(T):
    N = int(input())
    K = 0
    while 2**K <= N:
        K += 1
    
    parent = [[-1]*(N+1) for _ in range(K)]
    depth = [0]*(N+1)
    graph = [[] for _ in range(N+1)]
    for _ in range(N-1):
        a, b = map(int, input().split())
        parent[0][b] = a
        graph[a].append(b)
    
    root = 0
    for i in range(1, N+1):
        if parent[0][i] == -1:
            root = i
            break
    
    DFS(root, 0)
    for i in range(1, K):
        for j in range(1, N+1):
            parent[i][j] = parent[i-1][parent[i-1][j]]
    
    U, V = map(int, input().split())
    print(LCA(U, V))
```