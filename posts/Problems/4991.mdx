export const metadata = {
  title: '[Gold I] 로봇 청소기 - 4991',
  date: '2025-08-02 09:12:00',
  tags: ['그래프 이론', '브루트포스 알고리즘', '그래프 탐색', '너비 우선 탐색', '비트마스킹'],
  description: '[Gold I] 로봇 청소기 - 4991',
};

# [Gold I] 로봇 청소기 - 4991 

[문제 링크](https://www.acmicpc.net/problem/4991) 

### 성능 요약

메모리: 35100 KB, 시간: 292 ms

### 분류

그래프 이론, 브루트포스 알고리즘, 그래프 탐색, 너비 우선 탐색, 비트마스킹

### 제출 일자

2025년 8월 2일 18:11:43

### 문제 설명

오늘은 직사각형 모양의 방을 로봇 청소기를 이용해 청소하려고 한다. 이 로봇 청소기는 유저가 직접 경로를 설정할 수 있다.

방은 크기가 1×1인 정사각형 칸으로 나누어져 있으며, 로봇 청소기의 크기도 1×1이다. 칸은 깨끗한 칸과 더러운 칸으로 나누어져 있으며, 로봇 청소기는 더러운 칸을 방문해서 깨끗한 칸으로 바꿀 수 있다.

일부 칸에는 가구가 놓여져 있고, 가구의 크기도 1×1이다. 로봇 청소기는 가구가 놓여진 칸으로 이동할 수 없다. 

로봇은 한 번 움직일 때, 인접한 칸으로 이동할 수 있다. 또, 로봇은 같은 칸을 여러 번 방문할 수 있다.

방의 정보가 주어졌을 때, 더러운 칸을 모두 깨끗한 칸으로 만드는데 필요한 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

### 입력 

 입력은 여러 개의 테스트케이스로 이루어져 있다.

각 테스트 케이스의 첫째 줄에는 방의 가로 크기 w와 세로 크기 h가 주어진다. (1 ≤ w, h ≤ 20) 둘째 줄부터 h개의 줄에는 방의 정보가 주어진다. 방의 정보는 4가지 문자로만 이루어져 있으며, 각 문자의 의미는 다음과 같다.

	.: 깨끗한 칸
	*: 더러운 칸
	x: 가구
	o: 로봇 청소기의 시작 위치

더러운 칸의 개수는 10개를 넘지 않으며, 로봇 청소기의 개수는 항상 하나이다.

입력의 마지막 줄에는 0이 두 개 주어진다.

### 출력 

 각각의 테스트 케이스마다 더러운 칸을 모두 깨끗한 칸으로 바꾸는 이동 횟수의 최솟값을 한 줄에 하나씩 출력한다. 만약, 방문할 수 없는 더러운 칸이 존재하는 경우에는 -1을 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline
INF = float('inf')
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def BFS(r, c, board, dist):
    R = len(board)
    C = len(board[0])
    k = board[r][c]
    queue = deque([(r, c, 0)])
    visited = [[False]*C for _ in range(R)]
    visited[r][c] = True
    dist[k][k] = 0
    while queue:
        r, c, d = queue.popleft()
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if nr=R or nc=C:
                continue
            if board[nr][nc] == -2 or visited[nr][nc]:
                continue
            if board[nr][nc] >= 0:
                idx = board[nr][nc]
                dist[k][idx] = d+1
            
            visited[nr][nc] = True
            queue.append((nr, nc, d+1))

def solve(R, C, room):
    board = [[-1]*C for _ in range(R)]
    pos = []
    idx = 1
    for r in range(R):
        for c in range(C):
            if room[r][c] == 'o':
                pos.append((r, c))
                board[r][c] = 0
            elif room[r][c] == '*':
                pos.append((r, c))
                board[r][c] = idx
                idx += 1
            elif room[r][c] == 'x':
                board[r][c] = -2
    
    dist = [[INF]*idx for _ in range(idx)]
    for r, c in pos:
        BFS(r, c, board, dist)
    
    if max(max(row) for row in dist) == INF:
        return -1
    
    dp = [[INF]*idx for _ in range(1<<idx)]
    dp[0][0] = 0
    for mask in range(1<<idx):
        for i in range(idx):
            if dp[mask][i] == INF:
                continue
            for j in range(idx):
                if mask | (1<<j) != mask:
                    dp[mask|(1<<j)][j] = min(dp[mask|(1<<j)][j], dp[mask][i]+dist[i][j])
    
    return min(dp[(1<<idx)-1])
    

while True:
    C, R = map(int, input().split())
    if R == 0 and C == 0:
        break
    room = [list(input().strip()) for _ in range(R)]
    print(solve(R, C, room))

'''
BFS로 초기 위치 및 모든 더러운 칸의 위치간 거리를 계산
이후 외판원문제 처럼 최소거리 구하기
dp[mask][i] : mask의 방문 경로로 i번째 노드에 도착했을 때 최소거리
dp[mask | (1<<i)][i] = min(dp[mask|(1<<i)][i], dp[mask][k] + dist[k][i])
'''
```