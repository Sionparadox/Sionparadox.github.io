export const metadata = {
  title: '[Platinum IV] 탈옥 - 9376',
  date: '2025-08-02 07:16:02',
  tags: ['그래프 이론', '그래프 탐색', '너비 우선 탐색', '최단 경로', '데이크스트라', '0-1 너비 우선 탐색'],
  description: '[Platinum IV] 탈옥 - 9376',
};

# [Platinum IV] 탈옥 - 9376 

[문제 링크](https://www.acmicpc.net/problem/9376) 

### 성능 요약

메모리: 35068 KB, 시간: 688 ms

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색, 최단 경로, 데이크스트라, 0-1 너비 우선 탐색

### 제출 일자

2025년 8월 2일 16:15:47

### 문제 설명

상근이는 감옥에서 죄수 두 명을 탈옥시켜야 한다. 이 감옥은 1층짜리 건물이고, 상근이는 방금 평면도를 얻었다.

평면도에는 모든 벽과 문이 나타나있고, 탈옥시켜야 하는 죄수의 위치도 나타나 있다. 감옥은 무인 감옥으로 죄수 두 명이 감옥에 있는 유일한 사람이다.

문은 중앙 제어실에서만 열 수 있다. 상근이는 특별한 기술을 이용해 제어실을 통하지 않고 문을 열려고 한다. 하지만, 문을 열려면 시간이 매우 많이 걸린다. 두 죄수를 탈옥시키기 위해서 열어야 하는 문의 개수를 구하는 프로그램을 작성하시오. 문을 한 번 열면 계속 열린 상태로 있는다.

### 입력 

 첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 수는 100개를 넘지 않는다.

첫째 줄에는 평면도의 높이 h와 너비 w가 주어진다. (2 ≤ h, w ≤ 100) 다음 h개 줄에는 감옥의 평면도 정보가 주어지며, 빈 공간은 '.', 지나갈 수 없는 벽은 '*', 문은 '#', 죄수의 위치는 '$'이다.

상근이는 감옥 밖을 자유롭게 이동할 수 있고, 평면도에 표시된 죄수의 수는 항상 두 명이다. 각 죄수와 감옥의 바깥을 연결하는 경로가 항상 존재하는 경우만 입력으로 주어진다.

### 출력 

 각 테스트 케이스마다 두 죄수를 탈옥시키기 위해서 열어야 하는 문의 최솟값을 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline

def BFS(r, c, board):
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    R = len(board)
    C = len(board[0])
    res = [[float('inf')]*C for _ in range(R)]
    res[r][c] = 0
    queue = deque([(r, c)])
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            nxt = res[r][c]
            if nr=R or nc=C:
                continue
            if board[nr][nc] == '*':
                continue
            if board[nr][nc] == '#':
                nxt += 1
            if res[nr][nc] > nxt:
                res[nr][nc] = nxt
                queue.append((nr, nc))
    
    return res
    
def solve(R, C, board):
    pos = [(0, 0)]
    for r in range(1, R-1):
        for c in range(1, C-1):
            if board[r][c] == '$':
                pos.append((r, c))
    cnt = [[0]*C for _ in range(R)]
    for r in range(R):
        for c in range(C):
            if board[r][c] == '#':
                cnt[r][c] = -2
    
    for r, c in pos:
        tmp = BFS(r, c, board)
        for i in range(R):
            for j in range(C):
                cnt[i][j] += tmp[i][j]
    return min(min(row) for row in cnt)

T = int(input())
for _ in range(T):
    R, C = map(int, input().split())
    arr = [['.']*(C+2)]+[['.']+list(input().strip())+['.'] for _ in range(R)]+[['.']*(C+2)]
    print(solve(R+2, C+2, arr))

'''
벽 바깥에 '.'로 한칸씩 패딩
0,0과 죄수의 좌표 2곳에서 모든 칸까지의 지나온 문의 수를 계산. 
이후 3값의 합이 최소인 칸을 지나는 경로가 답
값에서 벽인 칸은 2씩 빼야함
'''
```