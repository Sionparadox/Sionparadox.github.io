export const metadata = {
  title: '[Platinum IV] 도시 왕복하기 1 - 17412',
  date: '2025-09-05 05:53:35',
  tags: ['그래프 이론', '최대 유량'],
  description: '[Platinum IV] 도시 왕복하기 1 - 17412',
};

# [Platinum IV] 도시 왕복하기 1 - 17412 

[문제 링크](https://www.acmicpc.net/problem/17412) 

### 성능 요약

메모리: 34984 KB, 시간: 104 ms

### 분류

그래프 이론, 최대 유량

### 제출 일자

2025년 9월 5일 14:53:08

### 문제 설명

N개의 도시가 P개의 단방향 길로 연결되어 있다. 이석원은 1번 도시와 2번 도시 사이를 가며 워해머를 한다. 성실한 이석원은 1번에서 2번으로 가는 서로 다른 경로를 최대한 많이 찾으려고 하는데, 이때 한 경로에 포함된 길이 다른 경로에 포함되면 안된다. 입력에는 1번 도시와 2번 도시를 연결하는 길은 없다. 도시의 번호는 1번부터 N번까지이다.

### 입력 

 첫째 줄에 두 정수 N(3 ≤ N ≤ 400), P(1 ≤ P ≤ 10,000)이 주어진다. 다음 P개의 줄에는 각 길이 연결하는 출발 도시와 도착 도시의 번호가 주어지며, 두 번호는 다르다.

### 출력 

 1번에서 2번으로 가는 서로 다른 경로의 최대 개수를 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline

N, P = map(int, input().split())
capacity = [[0]*N for _ in range(N)]
for _ in range(P):
    s, e = map(int, input().split())
    capacity[s-1][e-1] += 1

flow = [[0]*N for _ in range(N)]
parent = [-1]*N
max_flow = 0
source, sink = 0, 1

def BFS(source, sink):
    visited = [False]*N
    queue = deque([source])
    visited[source] = True
    while queue:
        curr = queue.popleft()
        
        for nxt in range(N):
            if visited[nxt]: continue
            if capacity[curr][nxt] > flow[curr][nxt]:
                visited[nxt] = True
                queue.append(nxt)
                parent[nxt] = curr
                if nxt == sink:
                    return True
    return False

while True:
    if not BFS(source, sink): break
    
    v = sink
    while v != source:
        flow[parent[v]][v] += 1
        flow[v][parent[v]] -= 1
        
        v = parent[v]
    max_flow += 1

print(max_flow)
```