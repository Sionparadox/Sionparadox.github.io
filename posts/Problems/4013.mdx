export const metadata = {
  title: '[Platinum II] ATM - 4013',
  date: '2025-08-29 09:12:20',
  tags: ['다이나믹 프로그래밍', '그래프 이론', '방향 비순환 그래프', '위상 정렬', '강한 연결 요소'],
  description: '[Platinum II] ATM - 4013',
};

# [Platinum II] ATM - 4013 

[문제 링크](https://www.acmicpc.net/problem/4013) 

### 성능 요약

메모리: 304632 KB, 시간: 3004 ms

### 분류

다이나믹 프로그래밍, 그래프 이론, 방향 비순환 그래프, 위상 정렬, 강한 연결 요소

### 제출 일자

2025년 8월 29일 18:11:37

### 문제 설명

인도의 도시 중 하나인 시루세리에는 모든 도로들이 일방통행으로 되어 있다. 도로들이 만나는 모든 교차로에는 시루세리 은행의 현금입출금기(ATM)가 설치되어 있다. 시루세리에는 유명한 레스토랑 체인인 아웃백 커리 하우스가 있다. 이 레스토랑의 각 체인점들은 교차로에만 위치한다. 물론 각 교차로마다 항상 이 레스토랑 체인점이 있는 것은 아니다. 이 레스토랑은 현금만 사용할 수 있다. 

시루세리에 사는 반디치는 오늘 오후에 이 레스토랑에서 가족들과 파티를 열려고 한다. 그런데 갖고 있는 현금이 부족하여 레스토랑으로 가는 동안에 가능한 한 많은 현금을 ATM 기기로부터 인출할 계획을 세웠다. 그는 자신의 집에서 출발하여 차로 이동하면서 통과하는 모든 교차로 ATM 기기에 들어있는 현금 전부를 인출하려고 한다. 차량의 최종 목적지는 아웃백 커리 하우스 체인점 중의 한 곳이고, 이 체인점이 어떤 교차로에 위치하는지는 상관없다.

반디치는 시루세리 은행의 홈페이지 정보를 통해 각 ATM 기기에 현금이 얼마나 들어 있는지를 알고 있다. 이동 시 동일한 도로나 교차로를 여러 번 지날 수 있다. ATM 기기의 현금은 새로 보충되지 않기 때문에 첫 번째 이후 다시 방문하는 교차로의 ATM 기기에는 인출할 현금이 없다.

예를 들어, 아래 그림처럼 도시에 6개의 교차로가 있다고 하자. 교차로는 원으로 표시되어 있고, 화살표는 도로를 나타낸다. 이중 원으로 표시된 교차로에는 레스토랑이 있다. 각 ATM 기기가 갖고 있는 현금의 액수는 교차로 위에 표시된 숫자이다. 이 예에서 현금 인출을 1번 교차로부터 시작한다면, 반디치는 1-2-4-1-2-3-5의 경로를 통해서 총 47의 현금을 인출할 수 있다.

![그림](https://www.acmicpc.net/upload/images/atm.png)

반디치가 출발 장소에서 어떤 레스토랑까지 이동하면서 인출할 수 있는 현금의 최대 액수가 얼마인지를 계산하는 프로그램을 작성하시오.

### 입력 

 첫째 줄에 교차로의 수와 도로의 수를 나타내는 2개의 정수 N과 M(N, M ≤ 500,000)이 차례로 주어진다. 교차로는 1부터 N까지 번호로 표시된다. 그 다음 M개의 줄에는 각 줄마다 각 도로의 시작 교차로 번호와 끝 교차로 번호를 나타내는 2개의 정수가 주어진다. 그 다음 N개의 줄에는 1번 교차로부터 차례대로 각 교차로의 ATM 기기가 보유한 현금의 액수를 나타내는 정수가 각 줄에 하나씩 주어진다. 그 다음 줄에는 두 개의 정수 S와 P가 주어진다. 여기서 S는 출발 장소(현금 인출의 시작 장소)인 교차로 번호이고 P는 레스토랑의 개수이다(1 ≤ P ≤ N). 그 다음 줄에는 각 레스토랑이 있는 교차로의 번호를 나열한 P개의 정수가 주어진다. 

각 ATM 기기에 들어 있는 현금의 액수는 0 이상 4,000 이하이다. 모든 입력에서 경로의 출발 장소로부터 일방통행 도로를 통해 도달 가능한 레스토랑이 항상 하나 이상 존재한다. 

### 출력 

 출력은 한 개의 정수이다. 이 정수는 반디치가 출발 장소에서 어떤 레스토랑까지 이동하면서 인출할 수 있는 현금의 최대 액수이다. 

### 풀이
```python
import sys
from collections import deque
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

N, M = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(M):
    u, v = map(int, input().split())
    u, v = u-1, v-1
    graph[u].append(v)

cash = [int(input()) for _ in range(N)]
S, P = map(int, input().split())
S -= 1
restaurant = set(x-1 for x in list(map(int, input().split())))

visited = [False]*N
labels = [0]*N
label = 0
groups = []
group_id = [-1]*N
group_num = 0
stack = []

def DFS(node):
    global label, group_num
    label += 1
    labels[node] = label
    parent = label
    visited[node] = True
    stack.append(node)
    
    for nxt in graph[node]:
        if not labels[nxt]:
            parent = min(parent, DFS(nxt))
        elif visited[nxt]:
            parent = min(parent, labels[nxt])
    
    if parent == labels[node]:
        group = []
        while stack:
            cur = stack.pop()
            visited[cur] = False
            group_id[cur] = group_num
            group.append(cur)
            if cur == node:
                break
        groups.append(group)
        group_num += 1
    
    return parent

for i in range(N):
    if not labels[i]:
        DFS(i)

G = len(groups)
group_cash = [0]*G
group_rest = [False]*G
for i in range(G):
    for g in groups[i]:
        group_cash[i] += cash[g]
        group_rest[i] |= g in restaurant

indegree = [0]*G
dp = [0]*G
can_visit = [False]*G

for node in range(N):
    for nxt in graph[node]:
        if group_id[node] != group_id[nxt]:
            indegree[group_id[nxt]] += 1

sg = group_id[S]
dp[sg] = group_cash[sg]
can_visit[sg] = True

queue = deque()
for i in range(G):
    if indegree[i] == 0:
        queue.append(i)

while queue:
    cur = queue.popleft()
    
    for node in groups[cur]:
        for nxt in graph[node]:
            ng = group_id[nxt]
            if cur == ng: continue

            indegree[ng] -= 1
            if indegree[ng] == 0:
                queue.append(ng)
            
            if can_visit[cur]:
                if dp[ng] < dp[cur] + group_cash[ng]:
                    dp[ng] = dp[cur] + group_cash[ng]
                can_visit[ng] = True

answer = 0
for i in range(G):
    if group_rest[i] and can_visit[i]:
        answer = max(answer, dp[i])

print(answer)
```