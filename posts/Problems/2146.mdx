export const metadata = {
  title: '[Gold III] 다리 만들기 - 2146',
  date: '2026-02-27 06:55:25',
  tags: ['그래프 이론', '그래프 탐색', '너비 우선 탐색'],
  description: '[Gold III] 다리 만들기 - 2146',
};

# [Gold III] 다리 만들기 - 2146 

[문제 링크](https://www.acmicpc.net/problem/2146) 

### 성능 요약

메모리: 35052 KB, 시간: 72 ms

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색

### 제출 일자

2026년 2월 27일 15:55:08

### 문제 설명

여러 섬으로 이루어진 나라가 있다. 이 나라의 대통령은 섬을 잇는 다리를 만들겠다는 공약으로 인기몰이를 해 당선될 수 있었다. 하지만 막상 대통령에 취임하자, 다리를 놓는다는 것이 아깝다는 생각을 하게 되었다. 그래서 그는, 생색내는 식으로 한 섬과 다른 섬을 잇는 다리 하나만을 만들기로 하였고, 그 또한 다리를 가장 짧게 하여 돈을 아끼려 하였다.

이 나라는 N×N크기의 이차원 평면상에 존재한다. 이 나라는 여러 섬으로 이루어져 있으며, 섬이란 동서남북으로 육지가 붙어있는 덩어리를 말한다. 다음은 세 개의 섬으로 이루어진 나라의 지도이다.

![그림](https://www.acmicpc.net/JudgeOnline/upload/201008/bri.PNG)

위의 그림에서 색이 있는 부분이 육지이고, 색이 없는 부분이 바다이다. 이 바다에 가장 짧은 다리를 놓아 두 대륙을 연결하고자 한다. 가장 짧은 다리란, 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리를 말한다. 다음 그림에서 두 대륙을 연결하는 다리를 볼 수 있다.

![그림](https://www.acmicpc.net/JudgeOnline/upload/201008/b2.PNG)

물론 위의 방법 외에도 다리를 놓는 방법이 여러 가지 있으나, 위의 경우가 놓는 다리의 길이가 3으로 가장 짧다(물론 길이가 3인 다른 다리를 놓을 수 있는 방법도 몇 가지 있다).

지도가 주어질 때, 가장 짧은 다리 하나를 놓아 두 대륙을 연결하는 방법을 찾으시오.

### 입력 

 첫 줄에는 지도의 크기 N(100이하의 자연수)가 주어진다. 그 다음 N줄에는 N개의 숫자가 빈칸을 사이에 두고 주어지며, 0은 바다, 1은 육지를 나타낸다. 항상 두 개 이상의 섬이 있는 데이터만 입력으로 주어진다.

### 출력 

 첫째 줄에 가장 짧은 다리의 길이를 출력한다.

### 풀이
```python
import sys
from collections import deque
input = sys.stdin.readline

N = int(input())
board = [list(map(int, input().split())) for _ in range(N)]

directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
indexed = [[0]*N for _ in range(N)]

def find_land(r, c, k):
    queue = deque([(r, c)])
    edge = set()
    indexed[r][c] = k
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if nr=N or nc=N:
                continue
            if indexed[nr][nc] > 0:
                continue
            if board[nr][nc]:
                indexed[nr][nc] = k
                queue.append((nr, nc))
            else:
                edge.add((r, c))
    
    return edge

cnt = 1
edges = []
for r in range(N):
    for c in range(N):
        if board[r][c] and indexed[r][c] == 0:
            edges.extend(find_land(r, c, cnt))
            cnt += 1

answer = 0
queue = deque(edges)
sign = 1
while True:
    answer += 1
    sign *= -1
    for _ in range(len(queue)):
        r, c = queue.popleft()
        k = abs(indexed[r][c])
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if nr=N or nc=N:
                continue
            if abs(indexed[nr][nc]) == k:
                continue
            if indexed[nr][nc] == 0:
                indexed[nr][nc] = k*sign
                queue.append((nr, nc))
            else:
                if indexed[nr][nc]*sign > 0:
                    answer = 2*answer -1
                else:
                    answer = (answer-1)*2
                print(answer)
                exit(0)
    
'''
BFS로 육지를 탐색
육지를 인덱싱(1-based)해두고 해변 타일을 저장해둠
이후 해변 타일에 대해 바다를 향해 leveling BFS
모든 섬이 동일한 거리로 확장하며 지나온 길은 짝수턴, 홀수턴에 따라 부호를 바꿔가며 저장
BFS를 돌다 동일한 점에 도착하면 부호에 따라 이번턴에 동시에 만난건지, 지난턴에 밟아둔건지 판정
'''
```