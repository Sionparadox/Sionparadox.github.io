export const metadata = {
  title: '[Gold II] 마피아 - 1079',
  date: '2026-02-27 10:00:42',
  tags: ['브루트포스 알고리즘', '백트래킹'],
  description: '[Gold II] 마피아 - 1079',
};

# [Gold II] 마피아 - 1079 

[문제 링크](https://www.acmicpc.net/problem/1079) 

### 성능 요약

메모리: 114412 KB, 시간: 1864 ms

### 분류

브루트포스 알고리즘, 백트래킹

### 제출 일자

2026년 2월 27일 19:00:00

### 문제 설명

은진이는 요즘 마피아라는 게임에 빠져 있다. 이 게임의 규칙은 다음과 같다.

	참가자는 두 그룹으로 나누어진다. 한 그룹은 마피아이고, 또 다른 그룹은 선량한 시민이다. 마피아의 정체는 시민에게 알려져 있지 않다. 참가자의 번호는 0번부터 시작한다.
	참가자가 짝수 명 남았을 때는 밤이다. 밤에는 마피아가 죽일 사람 한 명을 고른다. 죽은 사람은 게임에 더 이상 참여할 수 없다.
	참가자가 홀수 명 남았을 때는 낮이다. 낮에는 참가자들이 가장 죄가 있을 것 같은 사람 한 명을 죽인다.
	만약 게임에 마피아가 한 명도 안 남았다면, 그 게임은 시민 팀이 이긴 것이고, 시민이 한 명도 안 남았다면, 그 게임은 마피아 팀이 이긴 것이다. 게임은 즉시 종료된다.

게임을 잠시 동안 한 후에 은진이는 지금 이 게임에서 자기가 마지막으로 남은 마피아라는 것을 알았다. 따라서 은진이는 이 게임을 이기기 위해 방법을 생각하기 시작했다.

각 사람의 유죄 지수가 주어진다. 이 유죄 지수는 낮에 시민들이 어떤 참가자를 죽일 것인지 고를 때 쓰인다. 그리고 참가자 간의 반응을 나타내는 2차원 배열 R이 주어진다.

게임은 다음과 같이 진행된다.

	밤에는 마피아가 죽일 사람을 한 명 고른다. 이 경우 각 사람의 유죄 지수가 바뀐다. 만약 참가자 i가 죽었다면, 다른 참가자 j의 유죄 지수는 R[i][j]만큼 변한다.
	낮에는 현재 게임에 남아있는 사람 중에 유죄 지수가 가장 높은 사람을 죽인다. 그런 사람이 여러 명일 경우 그중 번호가 가장 작은 사람이 죽는다. 이 경우 유죄 지수는 바뀌지 않는다.

은진이는 되도록이면 이 게임을 오래 하고 싶다. 은진이가 이 게임에 정말 천재적으로 임하여 매번 최적의 선택을 할 때, 몇 번의 밤이 지나는지 출력하는 프로그램을 작성하시오.

### 입력 

 첫째 줄에 참가자의 수 N이 주어진다. 둘째 줄에는 각 참가자의 유죄 지수가 주어진다. 셋째 줄부터 N개의 줄에는 배열 R이 주어진다. 마지막 줄에는 은진이의 참가자 번호가 주어진다. N은 16보다 작거나 같은 자연수이고, 유죄 지수는 300보다 크거나 같고, 800보다 작거나 같은 자연수이다. R배열에 있는 수는 모두 절댓값이 1보다 크거나 같고 26보다 작거나 같은 정수이다.

### 출력 

 첫째 줄에 문제의 정답을 출력한다.

### 풀이
```python
import sys
input = sys.stdin.readline

N = int(input())
guilty = list(map(int, input().split()))
R = [list(map(int, input().split())) for _ in range(N)]
player = int(input())

dead = [False]*N

answer = 0
def backTrack(left, k):
    global answer
    
    if dead[player] or left == 1:
        answer = max(answer, k)
        return 

    
    #낮
    if left % 2 == 1:
        max_v = -1
        t = -1
        for i in range(N):
            if dead[i]:
                continue
            if guilty[i] > max_v:
                max_v = guilty[i]
                t = i
            
        dead[t] = True
        backTrack(left-1, k)
        dead[t] = False

    #밤
    else:
        for p in range(N):
            if dead[p] or p == player:
                continue
            
            dead[p] = True
            for i in range(N):
                if not dead[i]:
                    guilty[i] += R[p][i]
            
            backTrack(left-1, k+1)
            
            for i in range(N):
                if not dead[i]:
                    guilty[i] -= R[p][i]
            dead[p] = False
    

backTrack(N, 0)
print(answer)
        

'''
낮, 밤을 나눠서 백트래킹
낮은 분기 없이 선형으로 바로 선택
밤은 죽은사람 빼고 선택, 죽은 사람 guilty = -1
-> 시간초과
dp로 메모이제이션 추가 필요?? -> X 메모리 소비가 너무 큼
어레이 복사를 없애기

'''
```