export const metadata = {
  title: '[Gold I] 그래프 트리 분할 - 22954',
  date: '2025-06-27 06:03:01',
  tags: ['그래프 이론', '자료 구조', '그래프 탐색', '트리', '해 구성하기', '많은 조건 분기', '분리 집합'],
  description: '[Gold I] 그래프 트리 분할 - 22954',
};

# [Gold I] 그래프 트리 분할 - 22954 

[문제 링크](https://www.acmicpc.net/problem/22954) 

### 성능 요약

메모리: 84136 KB, 시간: 632 ms

### 분류

그래프 이론, 자료 구조, 그래프 탐색, 트리, 해 구성하기, 많은 조건 분기, 분리 집합

### 제출 일자

2025년 6월 27일 15:02:05

### 문제 설명

정점 개, 간선 개의 그래프가 주어진다.

각 정점은 부터 까지 번호가 매겨져 있고, 간선도 입력되는 순서대로 부터 까지 번호가 매겨져 있다.

그래프에서 원하는 만큼 간선을 삭제해, 서로 다른 크기의 트리 2개로 분할해보자!

각각의 트리는 하나 이상의 정점을 가지고 있어야 하며, 두 트리가 동일한 정점이나 간선을 공유해서는 안 된다.

### 입력 

 첫 번째 줄에 정점의 개수 , 간선의 개수이 주어진다. (, )

두 번째 줄부터 줄에 걸쳐서 간선을 나타내는 정수 와 가 주어진다. (, )

이는 번 정점과 번 정점을 잇는 양방향 간선이 존재함을 나타낸다. 중복 간선은 주어지지 않는다.

 

### 출력 

 그래프를 분할할 수 없다면 첫 번째 줄에 -1을 출력하고 종료한다.

분할 할 수 있는 방법이 존재한다면, 아무거나 하나, 아래와 같은 형식으로 출력한다.

첫 번째 줄에 두 트리의 크기 을 출력한다. (과 는 서로 다른 양의 정수이고, 을 만족해야 한다.)

두 번째 줄에는 첫 번째 트리에 속한 정점 개의 번호를 출력한다.

세 번째 줄에는 첫 번째 트리에 속한 간선 개의 번호를 출력한다.

네 번째 줄에는 두 번째 트리에 속한 정점 개의 번호를 출력한다.

다섯 번째 줄에는 두 번째 트리에 속한 간선 개의 번호를 출력한다.

출력한 트리 각각은 연결 그래프이고, 동일한 정점이나 간선을 공유해서는 안된다.

출력하는 모든 정점의 번호는 이상 이하를, 간선의 번호는 이상 이하를 만족해야 한다.

### 풀이
```python
import sys
from collections import defaultdict, deque
input = sys.stdin.readline

N, M = map(int, input().split())
if N2:
    print(-1)
    exit(0)

if L==2: 
    if len(trees[0]) == len(trees[1]):
        print(-1)
        exit(0)
    else:
        roots = set(find(i) for i in range(1, N+1))
        root_list = sorted(list(roots))

        tree_nodes = {root: [] for root in roots}
        for i in range(1, N+1):
            tree_nodes[find(i)].append(i)
        R1, R2 = root_list[0], root_list[1]
        L1, L2 = trees[0], trees[1]
        N1, N2 = tree_nodes[R1], tree_nodes[R2]
        print(len(N1), len(N2))
        print(' '.join(map(str, N1)))
        print(' '.join(map(str, L1)))
        print(' '.join(map(str, N2)))
        print(' '.join(map(str, L2)))
        exit(0)

for leaf in range(1, N+1):
    if degree[leaf] == 1:
        break

def removeLine(node):
    lines = graph[node]
    target = set(trees[0])
    for line in lines:
        if line[1] in target:
            target.remove(line[1])
    return sorted(list(target))

line = removeLine(leaf)
print(N-1, 1)
print(' '.join([str(x) for x in range(1, N+1) if x != leaf]))
print(' '.join(map(str, line)))
print(leaf)
print()

'''
모든 정점을 잇는 아무 트리를 하나 만듦.(스패닝트리)
N 분리 완료 (N-1크기의 트리와 1크기의 트리)

'''
```