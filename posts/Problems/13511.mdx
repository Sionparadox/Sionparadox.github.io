export const metadata = {
  title: '[Platinum III] 트리와 쿼리 2 - 13511',
  date: '2025-08-28 08:54:09',
  tags: ['자료 구조', '트리', '최소 공통 조상', '희소 배열'],
  description: '[Platinum III] 트리와 쿼리 2 - 13511',
};

# [Platinum III] 트리와 쿼리 2 - 13511 

[문제 링크](https://www.acmicpc.net/problem/13511) 

### 성능 요약

메모리: 112140 KB, 시간: 1792 ms

### 분류

자료 구조, 트리, 최소 공통 조상, 희소 배열

### 제출 일자

2025년 8월 28일 17:51:52

### 문제 설명

N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.

아래의 두 쿼리를 수행하는 프로그램을 작성하시오.

	1 u v: u에서 v로 가는 경로의 비용을 출력한다.
	2 u v k: u에서 v로 가는 경로에 존재하는 정점 중에서 k번째 정점을 출력한다. k는 u에서 v로 가는 경로에 포함된 정점의 수보다 작거나 같다.

### 입력 

 첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.

둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 간선의 비용 w가 주어진다.

다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.

다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.

간선의 비용은 항상 1,000,000보다 작거나 같은 자연수이다.

### 출력 

 각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.

### 풀이
```python
import sys
from collections import defaultdict
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

N = int(input())
graph = defaultdict(list)
for _ in range(N-1):
    u, v, w = map(int, input().split())
    graph[u].append((v, w))
    graph[v].append((u, w))

K = 0
while (1= 2**i:
            u = arr[i][u]
    
    if u == v:
        return u
    
    for i in range(K-1, -1, -1):
        if arr[i][u] != arr[i][v]:
            u = arr[i][u]
            v = arr[i][v]
    
    return arr[0][u]

def get_cost(s, e):
    lca = get_lca(s, e)
    return cost[s]+cost[e]-cost[lca]*2

def get_node(s, e, t):
    lca = get_lca(s, e)
    d = depth[s]-depth[lca]+1
    res = s
    if t 이후 K-1부터 내려가며 t번째 노드 구함. 
'''
```