export const metadata = {
  title: "TypeScript와 React의 모범 사례",
  date: "2024-03-11",
  tags: ["TypeScript", "React"],
  description: "TypeScript와 React를 함께 사용할 때의 모범 사례와 패턴을 알아봅니다. (임시파일)"
};

# TypeScript와 React의 모범 사례

TypeScript와 React를 함께 사용할 때의 다양한 패턴과 모범 사례를 살펴보겠습니다. 이 글에서는 실제 프로젝트에서 자주 사용되는 패턴들을 다룹니다.

## 타입 정의 패턴

컴포넌트의 props와 상태를 위한 타입 정의 방법:

```typescript
// Props 타입 정의
interface ButtonProps {
  variant: 'primary' | 'secondary';
  size: 'small' | 'medium' | 'large';
  onClick: () => void;
  children: React.ReactNode;
}

// 컴포넌트에서 사용
const Button: React.FC<ButtonProps> = ({
  variant,
  size,
  onClick,
  children
}) => {
  return (
    <button
      className={`btn-${variant} btn-${size}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

## 제네릭 활용

재사용 가능한 컴포넌트를 만들기 위한 제네릭 사용:

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}

// 사용 예시
interface User {
  id: number;
  name: string;
}

const users: User[] = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' }
];

<List
  items={users}
  renderItem={(user) => <div>{user.name}</div>}
/>
```

## 타입 가드

런타임에서 타입을 안전하게 확인하는 방법:

```typescript
interface User {
  type: 'user';
  name: string;
}

interface Admin {
  type: 'admin';
  name: string;
  permissions: string[];
}

type UserType = User | Admin;

function isAdmin(user: UserType): user is Admin {
  return user.type === 'admin';
}

function renderUser(user: UserType) {
  if (isAdmin(user)) {
    // 여기서는 user가 Admin 타입으로 추론됨
    return <div>Admin: {user.name} ({user.permissions.join(', ')})</div>;
  }
  // 여기서는 user가 User 타입으로 추론됨
  return <div>User: {user.name}</div>;
}
```

## 유틸리티 타입

TypeScript의 유틸리티 타입을 활용한 타입 조작:

```typescript
// 기존 타입에서 일부 속성만 선택
type ButtonProps = Pick<HTMLButtonElement, 'onClick' | 'className'>;

// 기존 타입에서 일부 속성 제외
type InputProps = Omit<HTMLInputElement, 'onChange'> & {
  onChange: (value: string) => void;
};

// 모든 속성을 선택적으로 변경
type PartialUser = Partial<User>;

// 모든 속성을 읽기 전용으로 변경
type ReadonlyUser = Readonly<User>;
```
## 마치며

TypeScript와 React를 함께 사용하면 타입 안정성과 개발 생산성을 모두 높일 수 있습니다. 
이 글에서 소개한 패턴들을 활용하여 더 안정적이고 유지보수하기 좋은 코드를 작성해보세요. 
